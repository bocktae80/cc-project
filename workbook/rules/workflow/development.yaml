# Development Rule
# 개발 원칙

id: development-001
name: 개발 원칙
description: |
  소프트웨어 개발 시 따라야 할 핵심 원칙.
  코드 품질, 테스트, 디버깅, 리팩토링에 대한 가이드라인.

category: workflow/development
tags:
  - development
  - coding
  - quality
  - testing
  - foundation

severity: warning

rules:
  code-quality:
    description: "코드 품질 원칙"
    items:
      - 읽기 쉬운 코드가 최우선 (Readability > Cleverness)
      - 한 함수는 한 가지 일만 수행 (Single Responsibility)
      - 중복을 발견하면 3회 이상일 때만 추상화 고려 (Rule of Three)
      - 조기 최적화를 피하고, 측정 후 최적화
      - 명시적인 것이 암묵적인 것보다 낫다 (Explicit > Implicit)
      - 하드코딩 금지 — 값은 설정/환경 변수, 타입은 인터페이스/제네릭, 의존성은 주입으로

  incremental-development:
    description: "점진적 개발 원칙"
    items:
      - 작은 단위로 작업하고 자주 커밋
      - 동작하는 상태를 유지하며 발전 (Always Green)
      - MVP 우선, 기능 추가는 검증 후
      - 큰 변경은 작은 단계로 나누어 진행

  testing:
    description: "테스트 원칙"
    items:
      - 핵심 로직에는 반드시 단위 테스트
      - 테스트는 문서이자 스펙 (테스트가 명세)
      - 경계값과 엣지 케이스를 먼저 고려
      - 실패하는 테스트를 먼저 작성 (TDD 권장)

  # === TDD (Test-Driven Development) ===
  tdd-cycle:
    description: "TDD 사이클 (Red-Green-Refactor)"
    items:
      - "1. RED: 실패하는 테스트를 먼저 작성"
      - "2. GREEN: 테스트를 통과하는 최소한의 코드 작성"
      - "3. REFACTOR: 코드 개선, 테스트는 여전히 통과"
      - "사이클은 짧게 - 한 번에 하나의 기능만"
      - "REFACTOR 단계를 건너뛰지 말 것"

  tdd-red-phase:
    description: "RED 단계 원칙"
    items:
      - 구현 전에 테스트 먼저 - "어떻게 사용할 것인가"부터 생각
      - 테스트는 반드시 실패해야 함 - 실패 안 하면 의미 없음
      - 명확한 실패 메시지 확인 - 왜 실패했는지 알 수 있어야
      - 한 번에 하나의 테스트만 작성
      - 테스트가 설계를 이끈다 (Test-First Design)

  tdd-green-phase:
    description: "GREEN 단계 원칙"
    items:
      - 테스트를 통과하는 가장 간단한 코드 작성
      - '"Fake it till you make it" - 하드코딩도 OK'
      - 완벽한 코드를 쓰려 하지 말 것 - 통과만 목표
      - 다른 테스트를 깨뜨리지 않을 것
      - 시간 제한 - 10분 안에 GREEN 안 되면 RED 재검토

  tdd-refactor-phase:
    description: "REFACTOR 단계 원칙"
    items:
      - 테스트가 통과하는 상태에서만 리팩토링
      - 중복 제거 (DRY)
      - 명확한 이름으로 변경
      - 작은 단위로 리팩토링, 매번 테스트 실행
      - 기능 추가와 리팩토링을 섞지 말 것

  tdd-test-qualities:
    description: "좋은 TDD 테스트의 특성 (FIRST)"
    items:
      - "Fast: 빠르게 실행 (밀리초 단위)"
      - "Isolated: 다른 테스트에 의존하지 않음"
      - "Repeatable: 언제 실행해도 같은 결과"
      - "Self-validating: Pass/Fail이 명확"
      - "Timely: 코드 작성 전에 테스트 작성"

  tdd-what-to-test:
    description: "TDD로 테스트할 것"
    items:
      - 비즈니스 로직 - 핵심 도메인 규칙
      - 조건 분기 - if/else, switch 로직
      - 경계 조건 - 최소, 최대, null, 빈 값
      - 예외 상황 - 에러 핸들링
      - 상태 변화 - 입력 → 출력 변환

  tdd-what-not-to-test:
    description: "TDD로 테스트하지 않을 것"
    items:
      - 외부 라이브러리/프레임워크 내부 동작
      - Private 메서드 직접 테스트 (Public 통해 간접 테스트)
      - Getter/Setter만 있는 DTO
      - 단순 위임(Delegation)만 하는 코드
      - 설정 파일, 상수

  tdd-mindset:
    description: "TDD 마인드셋"
    items:
      - "테스트는 비용이 아니라 설계 도구"
      - "코드를 작성하기 전에 '사용법'을 먼저 정의"
      - "작은 단계로 자신감 있게 진행"
      - "테스트가 어려우면 설계가 나쁜 것"
      - "완벽한 커버리지보다 의미 있는 테스트"
      - "TDD는 테스트 기법이 아니라 개발 기법"

  tdd-common-mistakes:
    description: "TDD 흔한 실수"
    items:
      - 테스트 여러 개를 한 번에 작성 (한 번에 하나씩!)
      - GREEN 단계에서 과도한 구현 (최소한만!)
      - REFACTOR 건너뛰기 (기술 부채 누적)
      - 테스트 통과 후 테스트 삭제 (절대 금지)
      - 너무 큰 단위로 진행 (작게 쪼개기)
      - 테스트가 구현을 따라가기 (테스트가 먼저!)

  debugging:
    description: "디버깅 원칙"
    items:
      - 재현 가능한 최소 케이스를 먼저 만들기
      - 가정하지 말고, 확인하기 (Print/Log로 검증)
      - 최근 변경 사항부터 의심
      - 문제를 해결하면 왜 발생했는지 원인 기록

  debugging-mindset:
    description: "디버깅 마인드셋"
    items:
      - 버그는 코드에 있다, 컴파일러/런타임 탓하지 말기
      - '"이건 말이 안 돼"는 내 이해가 틀렸다는 신호'
      - 문제를 설명하는 순간 답이 보인다 (Rubber Duck Debugging)
      - 30분 이상 막히면 쉬거나 다른 사람에게 설명하기
      - '"분명히 맞는데"라는 생각이 가장 위험'

  debugging-isolation:
    description: "문제 격리 기법"
    items:
      - Binary Search - 코드 절반씩 주석 처리하며 범위 좁히기
      - 최소 재현 케이스 - 문제와 무관한 코드 모두 제거
      - 입력 단순화 - 복잡한 데이터를 최소한으로 줄이기
      - 환경 격리 - 로컬/스테이징/프로덕션 차이 확인
      - git bisect - 문제가 시작된 커밋 찾기

  debugging-techniques:
    description: "디버깅 기법"
    items:
      - Print Debugging - 빠르지만 체계적으로 (입력→처리→출력)
      - Breakpoint - 상태를 멈추고 변수 값 확인
      - Watch - 특정 변수 값 변화 추적
      - Call Stack - 어디서 호출됐는지 역추적
      - Step Into/Over/Out - 실행 흐름 한 줄씩 따라가기

  debugging-checklist:
    description: "디버깅 체크리스트 (순서대로)"
    items:
      - 1. 에러 메시지 전체를 읽었는가?
      - 2. Stack trace의 내 코드 부분을 확인했는가?
      - 3. 실제 입력값이 예상과 같은가?
      - 4. 최근 변경한 코드가 있는가?
      - 5. 같은 문제를 검색해봤는가?
      - 6. 다른 환경(브라우저, 버전)에서도 재현되는가?
      - 7. 캐시/빌드를 클리어했는가?
      - 8. 의존성 버전이 맞는가?

  common-bug-patterns:
    description: "흔한 버그 패턴"
    items:
      - Off-by-one - 배열 인덱스, 반복 횟수 ±1 오류
      - Null/Undefined - 존재하지 않는 값 접근
      - Race Condition - 비동기 처리 순서 문제
      - State Mutation - 의도치 않은 상태 변경
      - Type Coercion - 암묵적 타입 변환 ('1' + 1 = '11')
      - Shallow Copy - 중첩 객체의 참조 공유
      - Closure Scope - 반복문 안의 클로저가 같은 변수 참조
      - Floating Point - 0.1 + 0.2 !== 0.3
      - Timezone - UTC/로컬 시간 혼용
      - Encoding - UTF-8/다른 인코딩 혼용

  debugging-logging:
    description: "로깅 전략"
    items:
      - 로그 레벨 구분 (debug < info < warn < error)
      - 컨텍스트 포함 (userId, requestId, timestamp)
      - 입구/출구 로깅 (함수 시작, 종료, 걸린 시간)
      - 민감 정보 마스킹 (비밀번호, 토큰)
      - 구조화된 로그 (JSON) - 검색/필터링 용이

  debugging-tools:
    description: "디버깅 도구 활용"
    items:
      - Browser DevTools - Network, Console, Sources, Performance
      - Node.js - --inspect 플래그로 Chrome DevTools 연결
      - VS Code - launch.json으로 디버거 설정
      - 프로파일러 - CPU, 메모리 병목 찾기
      - Network 탭 - 요청/응답 확인, 타이밍 분석

  debugging-ask-for-help:
    description: "도움 요청 시"
    items:
      - 무엇을 하려고 했는지 (목표)
      - 무엇이 발생했는지 (현상)
      - 무엇을 예상했는지 (기대)
      - 무엇을 시도했는지 (이미 한 것)
      - 최소 재현 코드/단계 (repro)

  refactoring:
    description: "리팩토링 원칙"
    items:
      - 동작하는 테스트가 있을 때만 리팩토링
      - 기능 추가와 리팩토링을 동시에 하지 않기
      - 작은 단위로 리팩토링, 매번 테스트 확인
      - 리팩토링 목적을 명확히 (성능? 가독성? 확장성?)

  error-handling:
    description: "에러 처리 원칙"
    items:
      - 예상 가능한 에러는 명시적으로 처리
      - 에러 메시지는 구체적이고 actionable하게
      - 로그는 디버깅에 충분한 컨텍스트 포함
      - 시스템 경계(외부 API, 사용자 입력)에서 검증

examples:
  good:
    - |
      # 읽기 쉬운 코드
      const isEligibleForDiscount = age >= 65 || membershipYears >= 10;
      if (isEligibleForDiscount) { applyDiscount(); }
    - |
      # 점진적 개발
      v1: 기본 CRUD 완성 → v2: 검색 추가 → v3: 필터링 추가
    - |
      # 테스트가 명세
      it('should return empty array when no users found', () => {
        expect(findUsers({ name: 'unknown' })).toEqual([]);
      });
    - |
      # 디버깅: 체계적 로깅
      console.log('[processOrder] 시작', { orderId, userId });
      console.log('[processOrder] 재고 확인 결과', { available });
      console.log('[processOrder] 결제 요청', { amount });
      console.log('[processOrder] 완료', { result, duration: Date.now() - start });
    - |
      # 디버깅: 문제 격리 (Binary Search)
      // 1. 전체 코드 실행 → 버그 발생
      // 2. 후반부 주석 → 버그 발생 → 전반부에 있음
      // 3. 전반부 절반 주석 → 버그 없음 → 주석 처리한 부분에 있음
      // 4. 범위를 좁혀가며 정확한 라인 찾기
    - |
      # 디버깅: 도움 요청 템플릿
      **목표:** 사용자 로그인 기능 구현
      **현상:** 로그인 버튼 클릭 시 "undefined is not a function" 에러
      **기대:** 로그인 성공 후 대시보드로 이동
      **시도한 것:**
      - console.log로 확인 → user 객체는 정상
      - 네트워크 탭 확인 → API 응답 200 OK
      **재현:** localhost:3000에서 test@test.com / password123으로 로그인
    - |
      # 디버깅: 구조화된 로그
      logger.info('Order processed', {
        orderId: '123',
        userId: 'user-456',
        amount: 50000,
        duration: 234,
        timestamp: new Date().toISOString()
      });
  bad:
    - "한 번에 전체 기능 구현 시도"
    - "테스트 없이 대규모 리팩토링"
    - "에러 메시지: 'Error occurred'"
    - "기능 추가하면서 동시에 구조 변경"
    - "console.log('here') - 무슨 값인지 알 수 없음"
    - "console.log(data) - 어디서 출력된 건지 알 수 없음"
    - "에러 발생 시 '안 돼요'라고만 보고"
    - "30분 이상 같은 방법으로 삽질"
    - "stack trace 안 읽고 에러 메시지만 검색"

exceptions:
  - 프로토타입/실험 단계에서는 테스트 생략 가능
  - 성능 크리티컬한 부분은 가독성보다 최적화 우선
  - 레거시 코드 긴급 수정 시 점진적 개발 예외

created: "2025-02-05T00:00:00Z"
updated: "2025-02-05T00:00:00Z"
scope: workspace
enabled: true

metadata:
  version: "1.0.0"
  status: active
  author: "@kent"
  source: builtin

platforms:
  cursor:
    enabled: true
    includeInRules: true
  claude:
    enabled: true
