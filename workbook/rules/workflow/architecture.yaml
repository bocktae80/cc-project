# Architecture Rule
# 아키텍처 설계 원칙

id: architecture-001
name: 아키텍처 설계 원칙
description: |
  시스템 아키텍처 설계 시 따라야 할 핵심 원칙.
  구조 설계, 의존성 관리, 확장성, 모듈화에 대한 가이드라인.

category: workflow/architecture
tags:
  - architecture
  - design
  - system
  - structure
  - foundation

severity: warning

rules:
  design-principles:
    description: "설계 원칙"
    items:
      - 단순함을 추구 (KISS - Keep It Simple, Stupid)
      - 필요한 것만 만들기 (YAGNI - You Aren't Gonna Need It)
      - 관심사 분리 (Separation of Concerns)
      - 의존성은 안정적인 방향으로 (Stable Dependencies Principle)
      - 인터페이스에 의존, 구현에 의존하지 않기
      - 하드코딩/하드타이핑 지양 — 주입(DI), 설정(Config), 동적 바인딩 우선

  configurability:
    description: "유연한 구성 원칙 (No Hardcoding)"
    items:
      - 값은 코드 밖으로 — 상수, URL, 키, 임계값은 설정 파일/환경 변수로 분리
      - 타입은 동적으로 — 구체 클래스 직접 참조 대신 인터페이스/제네릭/팩토리로 연결
      - 의존성은 주입으로 — new/import 직접 생성 대신 DI 컨테이너 또는 파라미터 주입
      - 구조는 플러거블하게 — 전략 패턴, 플러그인, 미들웨어 등 교체 가능한 구조 설계
      - 연결은 선언적으로 — 설정 파일, 레지스트리, 라우팅 테이블로 관계를 기술

  layered-architecture:
    description: "레이어 구조 원칙"
    items:
      - 명확한 레이어 경계 (UI → Business Logic → Data)
      - 하위 레이어는 상위 레이어를 알지 못함
      - 레이어 간 통신은 명시적 인터페이스로
      - 각 레이어는 독립적으로 테스트 가능해야 함

  modularity:
    description: "모듈화 원칙"
    items:
      - 높은 응집도 (관련 기능은 함께)
      - 낮은 결합도 (모듈 간 의존성 최소화)
      - 명확한 모듈 경계와 공개 인터페이스
      - 순환 의존성 금지

  scalability:
    description: "확장성 원칙"
    items:
      - 수평 확장 가능한 구조 설계
      - 상태를 최소화하고 stateless 선호
      - 병목 지점을 미리 식별하고 대비
      - 캐싱 전략을 설계 단계에서 고려

  decision-making:
    description: "의사결정 원칙"
    items:
      - 결정을 최대한 늦추기 (Last Responsible Moment)
      - 되돌리기 쉬운 결정과 어려운 결정 구분
      - 아키텍처 결정은 반드시 문서화 (ADR)
      - 트레이드오프를 명시적으로 기록

  technical-debt:
    description: "기술 부채 관리"
    items:
      - 의도적 부채는 기록하고 상환 계획 수립
      - 부채 발생 시 TODO/FIXME로 표시
      - 정기적으로 기술 부채 리뷰
      - 새 기능보다 부채 상환이 우선일 때를 판단

  architecture-patterns:
    description: "아키텍처 패턴"
    items:
      - Monolith - 단순, 배포 쉬움, 확장 한계
      - Modular Monolith - 모놀리스 + 모듈 경계 명확
      - Microservices - 독립 배포, 복잡도↑, 팀 자율성
      - Event-Driven - 느슨한 결합, 비동기, 추적 어려움
      - Serverless - 관리 부담↓, Cold Start, 벤더 종속
      - CQRS - 읽기/쓰기 분리, 복잡도↑
      - Event Sourcing - 이벤트 저장, 재생 가능, 학습 곡선

  architecture-selection:
    description: "아키텍처 선택 기준"
    items:
      - 팀 규모/구조 - 작은 팀은 모놀리스가 효율적
      - 도메인 복잡도 - 복잡하면 경계 분리 필요
      - 확장 요구 - 특정 부분만 확장 필요한가
      - 변경 빈도 - 자주 변하는 부분 분리
      - 팀 역량 - 익숙한 패턴 vs 새 패턴 학습 비용
      - 운영 역량 - 분산 시스템 운영 가능한가

  api-design:
    description: "API 설계 원칙"
    items:
      - 일관된 네이밍과 구조
      - 버전 관리 전략 (URL, Header, Accept)
      - 적절한 HTTP 메서드와 상태 코드
      - 에러 응답 형식 표준화
      - 페이지네이션/필터링 규칙 통일
      - Rate Limiting 설계
      - 하위 호환성 유지 (Breaking Change 최소화)

  api-design-tips:
    description: "API 설계 팁"
    items:
      - 명사 복수형 사용 (/users, /orders)
      - 계층 관계 표현 (/users/{id}/orders)
      - 필터는 쿼리 파라미터 (?status=active)
      - 액션은 동사 허용 (/orders/{id}/cancel)
      - 응답에 메타데이터 포함 (total, page, links)
      - 요청/응답 예시를 문서화

  data-design:
    description: "데이터 설계 원칙"
    items:
      - 정규화 vs 비정규화 트레이드오프 이해
      - 읽기 vs 쓰기 비율에 따른 최적화
      - 인덱스 전략 (쿼리 패턴 기반)
      - 데이터 일관성 수준 선택 (Strong, Eventual)
      - 민감 정보 암호화/마스킹
      - 데이터 보존/삭제 정책
      - 스키마 변경 전략 (Migration)

  security-design:
    description: "보안 설계 원칙"
    items:
      - Defense in Depth - 여러 겹의 보안 레이어
      - Least Privilege - 최소 권한 원칙
      - Secure by Default - 기본값이 안전하게
      - 입력 검증은 서버에서 (클라이언트 신뢰 X)
      - 비밀 정보는 환경 변수/Secret Manager
      - OWASP Top 10 체크
      - 보안 로깅 및 모니터링

  performance-design:
    description: "성능 설계 원칙"
    items:
      - 병목 지점 예측 (DB, Network, CPU)
      - 캐싱 전략 (무엇을, 어디서, 얼마나)
      - 비동기 처리 (무거운 작업은 백그라운드)
      - Connection Pooling
      - Lazy Loading vs Eager Loading
      - CDN 활용 (정적 자산)
      - 성능 예산 설정 (응답 시간, 페이지 크기)

  observability:
    description: "관찰 가능성 (Observability)"
    items:
      - Logging - 구조화된 로그, 상관 ID
      - Metrics - RED (Rate, Error, Duration), USE (Utilization, Saturation, Error)
      - Tracing - 분산 추적 (OpenTelemetry)
      - Alerting - 의미 있는 알림, 알림 피로 방지
      - Dashboard - 주요 지표 시각화
      - Health Check - 서비스 상태 엔드포인트

  resilience:
    description: "회복 탄력성 (Resilience)"
    items:
      - Timeout - 무한 대기 방지
      - Retry - 재시도 (Exponential Backoff)
      - Circuit Breaker - 장애 전파 차단
      - Bulkhead - 장애 격리 (리소스 분리)
      - Fallback - 대체 응답
      - Graceful Degradation - 부분 기능 유지

  migration-strategy:
    description: "마이그레이션 전략"
    items:
      - Strangler Fig - 점진적으로 새 시스템으로 이전
      - Branch by Abstraction - 추상화 뒤에서 교체
      - Parallel Run - 두 시스템 동시 운영, 결과 비교
      - Feature Toggle - 플래그로 신/구 전환
      - 롤백 계획 필수
      - 데이터 마이그레이션 별도 계획

  architecture-documentation:
    description: "아키텍처 문서화"
    items:
      - C4 Model - Context, Container, Component, Code
      - ADR (Architecture Decision Record) - 결정 기록
      - 시스템 컨텍스트 다이어그램
      - 시퀀스 다이어그램 (주요 흐름)
      - 배포 다이어그램
      - 문서는 코드와 함께 버전 관리

  adr-template:
    description: "ADR 템플릿"
    items:
      - 제목 - ADR-NNN. 결정 제목
      - 상태 - 제안/승인/폐기/대체
      - 컨텍스트 - 왜 이 결정이 필요한가
      - 결정 - 무엇을 선택했는가
      - 대안 - 검토한 다른 옵션들
      - 결과 - 이 결정으로 인한 영향
      - 날짜/작성자

  architecture-checklist:
    description: "아키텍처 체크리스트"
    items:
      - 1. 요구사항이 아키텍처에 반영되었는가?
      - 2. 비기능 요구사항(성능, 보안, 확장성)이 고려되었는가?
      - 3. 주요 컴포넌트와 책임이 명확한가?
      - 4. 의존성 방향이 적절한가?
      - 5. 단일 장애점(SPOF)이 없는가?
      - 6. 확장 시나리오가 고려되었는가?
      - 7. 배포/운영 방법이 명확한가?
      - 8. 모니터링/알림 전략이 있는가?
      - 9. 보안 위협이 분석되었는가?
      - 10. 결정 사항이 문서화되었는가?

  architecture-antipatterns:
    description: "안티패턴"
    items:
      - Big Ball of Mud - 구조 없는 코드 덩어리
      - Golden Hammer - 익숙한 도구로 모든 문제 해결
      - Premature Optimization - 필요 전 최적화
      - Resume-Driven Development - 경력용 기술 선택
      - Not Invented Here - 외부 솔루션 거부
      - Distributed Monolith - MSA 형태지만 강결합
      - Spaghetti Architecture - 얽힌 의존성
      - Hardcoded Everything - 값/타입/의존성을 코드에 직접 박아넣기

examples:
  good:
    - |
      # 명확한 레이어 구조
      src/
      ├── presentation/  # UI, Controllers
      ├── application/   # Use Cases, Services
      ├── domain/        # Business Logic, Entities
      └── infrastructure/  # DB, External APIs
    - |
      # 의존성 방향: 안정적인 쪽으로
      Controller → Service → Repository → Entity
      (불안정) ────────────────────────→ (안정)
    - |
      # ADR 문서화
      ## ADR-001: REST vs GraphQL
      상태: 승인
      결정: REST 선택
      이유: 팀 경험, 캐싱 용이성
      트레이드오프: Over-fetching 발생 가능
    - |
      # 아키텍처 패턴 선택 사례
      상황: 스타트업, 5명 팀, MVP 단계
      → Modular Monolith 선택
      이유:
        - 빠른 개발/배포
        - 팀 규모에 적합
        - 나중에 필요 시 분리 가능
        - 운영 복잡도 낮음
    - |
      # API 설계 예시
      # 좋은 예
      GET  /users                    # 목록 조회
      GET  /users/123                # 단건 조회
      POST /users                    # 생성
      PUT  /users/123                # 전체 수정
      PATCH /users/123               # 부분 수정
      DELETE /users/123              # 삭제
      GET  /users/123/orders         # 관계 조회
      POST /users/123/orders         # 관계 생성
      POST /orders/123/cancel        # 액션 (동사 허용)
    - |
      # 에러 응답 표준화
      {
        "error": {
          "code": "VALIDATION_ERROR",
          "message": "입력값이 유효하지 않습니다",
          "details": [
            { "field": "email", "reason": "이메일 형식이 아닙니다" }
          ],
          "requestId": "abc-123",
          "timestamp": "2024-01-15T10:30:00Z"
        }
      }
    - |
      # Circuit Breaker 설정 예시
      circuitBreaker:
        failureThreshold: 5      # 5회 실패 시
        successThreshold: 3      # 3회 성공 시 복구
        timeout: 30s             # 30초 후 half-open
        fallback: cachedResponse # 실패 시 캐시 응답
    - |
      # C4 Model - Container Diagram
      ┌─────────────────────────────────────────┐
      │               사용자                      │
      └──────────────────┬──────────────────────┘
                         ↓
      ┌─────────────────────────────────────────┐
      │          Web Application                 │
      │          (React, Next.js)                │
      └──────────────────┬──────────────────────┘
                         ↓
      ┌─────────────────────────────────────────┐
      │          API Server                      │
      │          (Node.js, Express)              │
      └───────┬─────────────────┬───────────────┘
              ↓                 ↓
      ┌───────────────┐  ┌────────────────┐
      │   Database    │  │  External API  │
      │  (PostgreSQL) │  │   (Payment)    │
      └───────────────┘  └────────────────┘
    - |
      # ADR 전체 예시
      ## ADR-002: 인증 방식

      **상태:** 승인

      **컨텍스트:**
      사용자 인증이 필요하며 모바일 앱도 지원해야 함

      **결정:**
      JWT + Refresh Token 방식 선택

      **대안:**
      1. Session 기반: 서버 상태 필요, 수평 확장 어려움
      2. JWT만: 토큰 탈취 시 무효화 어려움
      3. OAuth만: 자체 로그인 필요

      **결과:**
      - Stateless 서버 가능
      - Access Token 만료 15분, Refresh 7일
      - Refresh Token은 DB 저장 (무효화 가능)
      - 로그아웃 시 Refresh Token 삭제

      **날짜:** 2024-01-15
      **작성자:** @kent
    - |
      # Observability 구성
      Logging:
        - 구조화된 JSON 로그
        - 요청마다 correlationId 부여
        - 레벨: debug/info/warn/error

      Metrics:
        - 요청 수, 에러율, 응답 시간 (p50, p95, p99)
        - 비즈니스 지표 (가입 수, 주문 수)

      Tracing:
        - OpenTelemetry로 분산 추적
        - 주요 함수에 span 추가

      Alerting:
        - 에러율 > 1% → 슬랙 알림
        - p99 > 3초 → 슬랙 알림
        - 서비스 다운 → PagerDuty
    - |
      # Strangler Fig 마이그레이션
      Phase 1: 신규 기능은 새 시스템에 구현
      Phase 2: 트래픽 일부를 새 시스템으로 라우팅
      Phase 3: 기존 기능을 점진적으로 이전
      Phase 4: 기존 시스템 제거

      ┌─────────┐     ┌─────────┐
      │  Proxy  │────▶│   New   │ (신규 트래픽)
      │(Router) │     │ System  │
      │         │────▶│   Old   │ (기존 트래픽)
      └─────────┘     │ System  │
                      └─────────┘
  bad:
    - "모든 레이어가 DB에 직접 접근"
    - "순환 의존성 존재 (A → B → C → A)"
    - "아키텍처 결정을 구두로만 공유"
    - "확장성 고려 없이 단일 서버 가정"
    - "마이크로서비스 시작 (3명 팀)"
    - "Retry 무한 반복 (백오프 없음)"
    - "에러 응답 형식이 API마다 다름"
    - "모니터링 없이 프로덕션 배포"
    - "단일 장애점 (DB 하나, 서버 하나)"
    - "롤백 계획 없이 대규모 마이그레이션"
    - "보안은 나중에 생각"

exceptions:
  - 프로토타입은 단순한 구조 허용
  - 성능이 극도로 중요한 경우 레이어 우회 가능
  - 소규모 프로젝트는 간소화된 구조 허용

created: "2025-02-05T00:00:00Z"
updated: "2025-02-05T00:00:00Z"
scope: workspace
enabled: true

metadata:
  version: "1.0.0"
  status: active
  author: "@kent"
  source: builtin

platforms:
  cursor:
    enabled: true
    includeInRules: true
  claude:
    enabled: true
