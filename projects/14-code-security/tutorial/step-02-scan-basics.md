# Step 2: 보안 스캔 기초

> Claude에게 코드 보안 스캔을 요청하는 방법

---

## Enterprise/Team 보안 스캔

Claude Code의 **코드 보안 스캔**은 Enterprise/Team 플랜에서 제공되는 기능입니다.

```
                    +-----------------------+
Enterprise/Team --> | 자동 보안 스캔          |
  플랜             | - 코드 커밋 시 자동 실행  |
                   | - 심각도 분류            |
                   | - 상세 리포트            |
                   | - 수정 제안              |
                   +-----------------------+

                    +-----------------------+
개인 플랜 ---------> | 수동 보안 리뷰 요청     |
                   | - "이 코드 보안 검토해줘" |
                   | - 비슷한 수준의 분석 가능  |
                   | - 자동화는 안 됨          |
                   +-----------------------+
```

> 개인 플랜에서도 "이 코드를 보안 관점에서 검토해줘"라고 요청하면 비슷한 분석을 받을 수 있어요!

---

## 스캔 요청 방법

### Enterprise/Team: 자동 스캔

```
# 프로젝트 설정에서 보안 스캔 활성화 후
# 코드를 커밋하면 자동으로 스캔됩니다

> git commit -m "feat: 로그인 기능 추가"

Claude: 보안 스캔을 실행합니다...
[스캔 결과가 자동으로 표시됨]
```

### 개인 플랜: 수동 요청

```
> 이 파일을 보안 관점에서 검토해줘: src/auth/login.js

Claude: 보안 관점에서 코드를 분석하겠습니다...
```

또는 더 구체적으로:

```
> 이 코드에서 SQL 인젝션, XSS, 인증 우회 취약점이 있는지 확인해줘

> OWASP Top 10 기준으로 이 파일의 보안 취약점을 찾아줘

> 이 API 엔드포인트의 입력 검증이 충분한지 검토해줘
```

---

## 스캔 결과 읽는 법

보안 스캔 결과는 **심각도**별로 분류됩니다.

### 심각도 등급

```
심각도 체계:

+----------+-------+--------------------------------------+
| 심각도    | 색상  | 설명                                  |
+----------+-------+--------------------------------------+
| 심각     | 빨강  | 즉시 수정 필요. 데이터 유출/시스템 장악 가능  |
| (CRITICAL)|      | 예: SQL 인젝션, 인증 우회              |
+----------+-------+--------------------------------------+
| 높음     | 주황  | 빠른 수정 필요. 중요 데이터 접근 가능     |
| (HIGH)   |      | 예: XSS, 비밀번호 평문 저장            |
+----------+-------+--------------------------------------+
| 보통     | 노랑  | 계획적 수정. 잠재적 위험              |
| (MEDIUM) |      | 예: 에러 정보 노출, 약한 암호화        |
+----------+-------+--------------------------------------+
| 낮음     | 파랑  | 개선 권장. 직접적 위험은 적음           |
| (LOW)    |      | 예: 불필요한 console.log, 약한 설정    |
+----------+-------+--------------------------------------+
```

비유:
```
심각 = 현관문이 활짝 열려있음         → 지금 당장 잠가!
높음 = 창문 잠금이 고장남             → 오늘 안에 수리!
보통 = 울타리가 낮아서 넘기 쉬움      → 이번 주에 높이자
낮음 = 초인종 카메라 화질이 낮음      → 시간 될 때 교체
```

---

## 시뮬레이션: 스캔 실행해보기

아래는 취약한 코드를 스캔했을 때의 **예상 출력**입니다.

### 스캔 대상 코드

```javascript
// server.js
const express = require('express');
const app = express();

// 사용자 검색 API
app.get('/api/search', (req, res) => {
  const keyword = req.query.q;
  const query = `SELECT * FROM products WHERE name LIKE '%${keyword}%'`;
  db.query(query, (err, results) => {
    if (err) {
      res.status(500).send(`Error: ${err.message}`);
    }
    res.json(results);
  });
});

// 비밀번호 변경 API
app.post('/api/change-password', (req, res) => {
  const { userId, newPassword } = req.body;
  db.query(`UPDATE users SET password = '${newPassword}' WHERE id = ${userId}`);
  res.send('비밀번호가 변경되었습니다');
});

app.listen(3000);
```

### 스캔 결과 (시뮬레이션)

```
=== Claude Code 보안 스캔 결과 ===
파일: server.js
스캔 시간: 2024-01-15 14:30:22
총 발견: 6건 (심각 2, 높음 2, 보통 1, 낮음 1)

────────────────────────────────────────

[심각] SQL-INJ-001: SQL 인젝션
  위치: Line 8
  코드: `SELECT * FROM products WHERE name LIKE '%${keyword}%'`
  설명: 사용자 입력(req.query.q)이 검증 없이 SQL 쿼리에 직접 삽입됨.
        공격자가 악의적인 SQL을 주입하여 DB 전체를 탈취할 수 있음.
  수정: 파라미터화 쿼리 사용
    db.query('SELECT * FROM products WHERE name LIKE ?', [`%${keyword}%`])

────────────────────────────────────────

[심각] SQL-INJ-002: SQL 인젝션
  위치: Line 17
  코드: `UPDATE users SET password = '${newPassword}' WHERE id = ${userId}`
  설명: userId와 newPassword 모두 검증 없이 SQL에 삽입됨.
        공격자가 다른 사용자의 비밀번호를 변경할 수 있음.
  수정: 파라미터화 쿼리 + 인증 확인
    db.query('UPDATE users SET password = ? WHERE id = ?', [hashedPw, userId])

────────────────────────────────────────

[높음] AUTH-001: 인증 미확인
  위치: Line 16 (/api/change-password)
  설명: 비밀번호 변경 API에 인증 미들웨어가 없음.
        로그인하지 않은 사용자도 다른 사람의 비밀번호를 변경 가능.
  수정: 인증 미들웨어 추가
    app.post('/api/change-password', requireAuth, (req, res) => ...)

────────────────────────────────────────

[높음] CRYPTO-001: 비밀번호 평문 저장
  위치: Line 17
  설명: 비밀번호를 해시하지 않고 직접 DB에 저장.
        DB 유출 시 모든 비밀번호가 노출됨.
  수정: bcrypt 해시 사용
    const hashed = await bcrypt.hash(newPassword, 10);

────────────────────────────────────────

[보통] INFO-001: 에러 정보 노출
  위치: Line 10
  코드: res.status(500).send(`Error: ${err.message}`)
  설명: 에러 메시지에 DB 구조, 쿼리 정보 등이 포함될 수 있음.
  수정: 일반적인 에러 메시지로 대체
    res.status(500).json({ error: '서버 오류가 발생했습니다' });

────────────────────────────────────────

[낮음] FLOW-001: 에러 후 응답 중복
  위치: Line 9-12
  설명: err 발생 시 return 없이 res.json(results)도 실행됨.
  수정: return 추가
    if (err) { return res.status(500)...; }

=== 스캔 완료 ===
권장: 심각(2건) → 높음(2건) 순서로 즉시 수정하세요.
```

---

## 스캔 결과 요약 보는 법

```
스캔 요약 대시보드 (시뮬레이션):

  심각도별 분포
  ─────────────────────────────
  심각  ||||||  2건
  높음  ||||||  2건
  보통  |||     1건
  낮음  ||      1건
  ─────────────────────────────
  합계: 6건

  취약점 유형별 분포
  ─────────────────────────────
  SQL 인젝션     |||||||  2건
  인증 미확인    ||||     1건
  암호화 부재    ||||     1건
  정보 노출      |||      1건
  흐름 제어      ||       1건
  ─────────────────────────────
```

---

## 직접 해보기

Claude에게 다음과 같이 요청해보세요:

```
> examples/vulnerable-code/ 폴더의 파일들을 보안 관점에서 분석해줘.
> 각 파일의 취약점을 심각도와 함께 정리해줘.
```

또는 하나씩:

```
> examples/vulnerable-code/sql-injection.js를 읽고
> 취약한 부분과 수정된 부분의 차이를 설명해줘
```

---

## 확인 체크리스트

- [ ] 심각도 4단계를 이해했나요? (심각/높음/보통/낮음)
- [ ] 스캔 결과를 읽을 수 있나요?
- [ ] Enterprise/Team과 개인 플랜의 차이를 이해했나요?

---

## 다음 단계

- [Step 3: 수정 워크플로우](./step-03-fix-workflow.md) — 취약점을 발견하고 고치는 전체 과정
